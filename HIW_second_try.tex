\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{natbib}

\setbeamertemplate{itemize items}[square]

\begin{document}
\title{Rebooting Supercompilation for Haskell}

\author[Ömer\,S.\,Ağacan \& Ryan\,R.\,Newton]
{%
  \texorpdfstring{
    \begin{columns}
      \column{.45\linewidth}
      \centering
      Ömer S. Ağacan\\
      \href{mailto:oagacan@indiana.edu}{oagacan@indiana.edu}
      \column{.45\linewidth}
      \centering
      Ryan R. Newton\\
      \href{mailto:rrnewton@indiana.edu}{rrnewton@indiana.edu}
    \end{columns}
  }
  {Ömer\,S.\,Ağacan \& Ryan\,R.\,Newton}
}

\date{\today}

\frame{\titlepage}

%\frame{\frametitle{Table of contents}\tableofcontents}

\begin{frame}
    \frametitle{Rebooting Supercompilation for Haskell - Talk outline}

    \begin{itemize}[<+->]
        \item
            An overview of supercompilation.
        \item
            What's interesting about it in the context of Haskell? Current
            state-of-the-art.
        \item
            Overview of how it works.
        \item
            "But where's my supercompiler for Haskell?" My preliminary work and
            research goals.
    \end{itemize}
\end{frame}

\begin{frame}

    \frametitle{Supercompilation: An overview}

    \begin{itemize}[<+->]
        \item
            The paper that describes the idea in English: "The Concept of a
            Supercompiler" \citet{Turchin86theconcept}.
        \item
            High-level idea:
            \setbeamertemplate{itemize items}[circle]
            \begin{itemize}
                \item
                    Evaluate programs in compile-time, while making the most out
                    of known inputs and definitions.
                    \setbeamertemplate{itemize items}[square]
                    \begin{itemize}
                        \item
                            Definitions of used functions.
                        \item
                            Statically known arguments of functions.
                        \item
                            When branching, propagate learned information
                            through branches and make use of that information
                            while compiling branches. (case expressions)
                    \end{itemize}
            \end{itemize}
    \end{itemize}

\end{frame}

\begin{frame}
    \frametitle{Supercompilation: An overview}

    \begin{itemize}
        \item
            The paper that describes the idea in English: "The Concept of a
            Supercompiler" \citet{Turchin86theconcept}.
        \item
            High-level idea: (contd)
            \setbeamertemplate{itemize items}[circle]
            \begin{itemize}
                \item
                    Evaluate programs in compile-time, while making the most out
                    of known inputs and definitions.
                    \setbeamertemplate{itemize items}[square]
                    \begin{itemize}[<+->]
                        \item
                            Most of the time the goal is to generate more
                            efficient programs. \newline
                            (but see \citet{Klyuchnikov2010proving} for a
                            different use of supercompilation)
                    \end{itemize}
            \end{itemize}
    \end{itemize}
\end{frame}


\begin{frame}
    \frametitle{Supercompilation in the context of Haskell}

    \begin{itemize}
        \item
            Why is it interesting?
        \item
            In a sense, it's the "ultimate" optimization. ("-O99")
        \item
            This optimizes in the sense that:

            If we have a programs $\mathcal{P}_1$ and $\mathcal{P}_2$, and
            \newline
            $\mathcal{P}_1 \Downarrow v$ in $N$ steps and \newline
            $\mathcal{P}_2 \Downarrow v$ in $M$ steps, \newline
            we consider $\mathcal{P}_2$ optimized if $M \textless N$.
        \item
            An approximation, but works well in practice.
    \end{itemize}
\end{frame}


\begin{frame}
    \frametitle{Supercompilation in the context of Haskell}

    \begin{itemize}
        \item
            It generalizes:
            \begin{itemize}
                \item
                    Deforestation(\citet{deforestation})
                \item
                    Partial evaluation
                \item
                    Call-pattern specialization(\citet{callpatternspec})
                \item
                    Ad-hoc optimizations via rewrite rules, e.g. shortcut fusion
                    (\citet{shortcutdeforestation}) or library-specific rewrite
                    rules
                \item
                    "Optimizing SYB is Easy!"(\citet{optimizingsyb}) and
                    "Optimizing Generics is Easy!"(\citet{optimizinggenerics})
                    style "domain-specific" partial evaluators
                \item
                    Function specialization(\texttt{SPECIALIZE} pragmas)
                \item
                    ... and many more
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Current state-of-the-art}

    \begin{itemize}
        \item
            \citet{callbyneed-sc} shows some great potential:
            \begin{itemize}
                \item
                    Up to $-95.1\%$ runtime improvement.
                \item
                    Up to $-100.0\%$ allocation improvement.
            \end{itemize}
        \item
            But it also suffers from problems that are inherent to
            supercompilation:
            \begin{itemize}
                \item
                    "We do not attempt to supercompile the full Nofib suite because the
                    other Nofib benchmarks are considerably more complicated and
                    generally suffer from extremely long supercompilation times."
                    \newline
                    (\citet{timeandspace} focuses on compilation performance,
                    and reports \textit{$<$3 seconds} for all the small programs
                    from Nofib)
                \item
                    Up to $+132002.0\%$ in compile time.
                \item
                    Up to $+188.9\%$ in generated code size.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{How it works? An overview}

    \begin{itemize}
        \item
            \citet{callbyneed-sc} laid out a great framework for
            supercompiling Haskell:
            \begin{itemize}[<+->]
                \item
                    \textcolor{blue}{Driving:} Take steps according to operational
                    semantics.  Some additional steps like case-of-case
                    transformation(\citet{Jones98atransformation-based}).
                \item
                    \textcolor{blue}{Splitting:} When stuck, keep evaluating
                    sub-expressions. Propagate information. After evaluating
                    sub-expressions combine results.
                \item
                    \textcolor{blue}{Matching:} Evaluating open terms lead to loops.
                    Matcher tried to detect loops, returns information about how to
                    refer to this new loop.
                \item
                    \textcolor{blue}{Termination checking:} Because perfect matcher is
                    not possible, and some programs just loop.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{How it works? An overview}
    \begin{minted}{haskell}
mapOfMap f g = (.) (map f) (map g)

h1 f g a = map f (map g a)

h2 f g a =
  (\f lst -> case lst of
               []    -> []
               h : t -> f h : map f t) f (map g a)

h3 f g a =
  case (map g a) of
    []    -> []
    h : t -> f h : map f t
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{How it works? An overview}
    \begin{minted}{haskell}
h3 f g a =
  case (map g a) of
    []    -> []
    h : t -> f h : map f t

h4 f g a =
  case (case a of
          []      -> []
          h1 : t1 -> g h1 : map g t1) of
    []      -> []
    h0 : t0 -> f h0 : map f t0
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{How it works? An overview}
    \begin{minted}{haskell}
h4 f g a =
  case (case a of
          []      -> []
          h1 : t1 -> g h1 : map g t1) of
    []      -> []
    h0 : t0 -> f h0 : map f t0
    \end{minted}

    Case-of-case transformation: (\citet{Jones98atransformation-based})

    \begin{minted}{haskell}
h5 f g a =
  case a of
    [] -> case [] of
            []      -> []
            h0 : t0 -> f h0 : map f t0
    h1 : t1 ->
      case (g h1 : map g t1) of
        []      -> []
        h0 : t0 -> f h0 : map f t0
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{How it works? An overview}
    \begin{minted}{haskell}
h5 f g a =
  case a of
    [] -> case [] of
            []      -> []
            h0 : t0 -> f h0 : map f t0
    h1 : t1 ->
      case (g h1 : map g t1) of
        []      -> []
        h0 : t0 -> f h0 : map f t0

h6 f g a =
  case a of
    []    -> []
    h : t -> f (g h) : map f (map g t)
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{How it works? An overview}
    \begin{minted}{haskell}
h6 f g a =
  case a of
    []    -> []
    h : t -> f (g h) : map f (map g t)
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{How it works? An overview}
    \begin{itemize}
        \itemsep1em
        \item[]
            \begin{minted}{haskell}
h6 f g a =
  case a of
    []    -> []
    h : t -> f (g h) : map f (map g t)

            \end{minted}

        \item[]
            \begin{center}
                \rule{4cm}{0.4pt}
            \end{center}

        \item[]
            \begin{minted}{haskell}
    map f (map g t)
            \end{minted}

        \item[]
            Looks similar to:

        \item[]
            \begin{minted}{haskell}
h1 f g a = map f (map g a)
            \end{minted}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{How it works? An overview}
    \begin{itemize}
        \itemsep1em
        \item[]
            At this point splitter tell us there's a loop.

        \item[]
            \begin{minted}{haskell}
h7 f g a =
  case a of
    []    -> []
    h : t -> f (g h) : h7 f g t
            \end{minted}

        \item[]
            Supercompiled version doesn't generate intermediate list.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Another example, growing arguments}
    \begin{minted}{haskell}
reverse_acc []      acc = acc
reverse_acc (h : t) acc = reverse_acc t (h : acc)
goal lst = reverse_acc (reverse_acc lst []) []

h0 lst = reverse_acc (reverse_acc lst []) []
...
h5 lst = case lst of
    []      -> []
    h1 : t1 -> case (reverse_acc t1 (h1 : [])) of
        []      -> []
        h0 : t0 -> reverse_acc t0 (h0 : [])
...
h_ lst = ... reverse_acc t1 (h1 : []) ...
...
h_ lst = ... reverse_acc t2 (h2 : h1 : []) ...
...
    \end{minted}
\end{frame}

\begin{frame}[allowframebreaks]
    \frametitle{References}

    \bibliographystyle{abbrvnat}
    \bibliography{refs}
\end{frame}

\end{document}
