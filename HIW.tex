
\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{minted}

\setbeamertemplate{itemize items}[square]

\begin{document}
\title{Rebooting Supercompilation for Haskell}

\author[Ömer\,S.\,Ağacan \& Ryan\,R.\,Newton]
{%
  \texorpdfstring{
    \begin{columns}%[onlytextwidth]
      \column{.45\linewidth}
      \centering
      Ömer S. Ağacan\\
      \href{mailto:oagacan@indiana.edu}{oagacan@indiana.edu}
      \column{.45\linewidth}
      \centering
      Ryan R. Newton\\
      \href{mailto:rrnewton@indiana.edu}{rrnewton@indiana.edu}
    \end{columns}
  }
  {Ömer\,S.\,Ağacan \& Ryan\,R.\,Newton}
}

\date{\today}

\frame{\titlepage}

%\frame{\frametitle{Table of contents}\tableofcontents}

\begin{frame}
    \frametitle{Rebooting Supercompilation for Haskell}

    \begin{itemize}[<+->]
        \item An overview of supercompilation and problems associated with it.
        \item Why it's worth rebooting, and why GHC is a great compiler to base
            this work on.
        \item My preliminary work, and problems I encountered while working on
            a GHC plugin.
        \item What's next? My research goals.
    \end{itemize}
\end{frame}

\begin{frame}

    \frametitle{Supercompilation: An overview}

    \begin{itemize}[<+->]
        \item The paper that describes the idea in English: "The Concept of a
            Supercompiler" \cite{Turchin86theconcept}.
        \item High-level idea:
            \setbeamertemplate{itemize items}[circle]
            \begin{itemize}
                \item Evaluate programs in compile-time, while making the most
                    out of known inputs and definitions.
                    \setbeamertemplate{itemize items}[square]
                    \begin{itemize}
                        \item Definitions of used functions.
                        \item Statically known arguments of functions.
                        \item When branching, propagate learned information
                            through branches and make use of that information
                            while compiling branches.
                    \end{itemize}
            \end{itemize}
    \end{itemize}

\end{frame}

\begin{frame}

    \frametitle{Supercompilation: An overview}

    \begin{itemize}
        \item The paper that describes the idea in English: "The Concept of a
            Supercompiler" \cite{Turchin86theconcept}.
        \item High-level idea: (contd)
            \setbeamertemplate{itemize items}[circle]
            \begin{itemize}
                \item Evaluate programs in compile-time, while making the most
                    out of known inputs and definitions.
                    \setbeamertemplate{itemize items}[square]
                    \begin{itemize}[<+->]
                        \item Most of the time the goal is to generate more
                            efficient programs. \newline
                            (but see \cite{Klyuchnikov2010proving} for a
                            different use of supercompilation)

                        \item Just make sure to preserve semantics :)
                    \end{itemize}
            \end{itemize}
    \end{itemize}

\end{frame}

\begin{frame}

    \frametitle{Supercompilation: An overview}

    \begin{itemize}[<+->]
        \item One nice idea here is to base supercompilation algorithm on the
            language's operational semantics, as done in \cite{SCbyEval}.

        \item This optimizes in the sense that:

            If we have a programs $\mathcal{P}_1$ and $\mathcal{P}_2$, and
            \newline
            $\mathcal{P}_1 \Downarrow v$ in $N$ steps and \newline
            $\mathcal{P}_2 \Downarrow v$ in $M$ steps, \newline
            we consider $\mathcal{P}_2$ optimized if $M \textless N$.

        \item An approximation. It's very unlikely that all of the rules have
            same costs.
    \end{itemize}

\end{frame}

\begin{frame}[fragile]

    \frametitle{An example}

    \begin{itemize}[<+->]
        \item[]
            \begin{minted}{haskell}
-- mapOfMap f g = map f . map g
mapOfMap = \f -> \g -> (.) (map f) (map g)
            \end{minted}

        \item[]
            We compile RHS of this definition, and we introduce a new definition
            at each step. We give it a fresh name, and add arguments for free
            variables in the expression.

        \item[]
            When we get stuck, we keep evaluating sub-expressions.

    \end{itemize}

\end{frame}

\begin{frame}[fragile]

    \frametitle{An example}

    \begin{itemize}[<+->]

        \item[]
            \begin{minted}{haskell}
-- mapOfMap f g = map f . map g
mapOfMap = \f -> \g -> (.) (map f) (map g)
            \end{minted}

        \item[]
            Lookup \texttt{(.)}:
            $\beta$-reduction:

        \item[]
            \begin{minted}{haskell}
h1 = \f -> \g ->
       (\f1 -> \f2 -> \a -> f1 (f2 a))
       (map f) (map g)
            \end{minted}

        \item[]
            $\beta$-reduction:

        \item[]
            \begin{minted}{haskell}
h2 = \f -> \g ->
       (\f2 -> \a -> (map f) (f2 a)) (map g)
            \end{minted}

        \item[]
            $\beta$-reduction:

        \item[]
            \begin{minted}{haskell}
h3 = \f -> \g -> \a -> (map f) (map g a)
            \end{minted}

    \end{itemize}

\end{frame}

\begin{frame}[fragile]

    \begin{itemize}[<+->]

        \item[]
            \begin{minted}{haskell}
h3 f g a = (map f) (map g a)
            \end{minted}

        \item[] Lookup \texttt{map}:

        \item[]
            \begin{minted}{haskell}
h5 f g a = ((\f -> \l ->
               case l of
                 []    -> []
                 h : t -> f h : map f t) f) (map g a)
              \end{minted}

          \item[] $\beta$-reduction (twice):

          \item[]
              \begin{minted}{haskell}
h6 f g a = case (map g a) of
             []    -> []
             h : t -> f h : map f t
              \end{minted}

          \item[] Lookup \texttt{map}, beta reduction:

          \item[]
              \begin{minted}{haskell}
h7 f g a = case (case a of
                   []      -> []
                   h1 : t1 -> g h1 : map g t1) of
             []      -> []
             h0 : t0 -> f h0 : map f t0
              \end{minted}

    \end{itemize}

\end{frame}

\begin{frame}[fragile]

    \begin{itemize}[<+->]
        \item[] Case-of-case transformation:
            (\cite{Jones98atransformation-based})

        \item[]
            \begin{minted}{haskell}
h8 f g a = case a of
             [] -> case [] of
                     []      -> []
                     h0 : t0 -> f h0 : map f t0
             h1 : t1 -> case (g h1 : map g t1) of
                          []      -> []
                          h0 : t0 -> f h0 : map f t0
            \end{minted}

        \item[] At this point we consider all branches, let's start with first
            one:

        \item[]
            \begin{minted}{haskell}
            case [] of
              [] -> []
              h0 : t0 -> f h0 : map f t0
            \end{minted}

        \item[] Known case reduction evaluates this to it's final form, and we
            update our expression to:

    \end{itemize}

\end{frame}

\begin{frame}[fragile]

    \begin{itemize}[<+->]
        \item[]
            \begin{minted}{haskell}
h9 f g a = case a of
             []      -> []
             h1 : t1 -> case (g h1 : map g t1) of
                          []      -> []
                          h0 : t0 -> f h0 : map f t0
            \end{minted}

        \item[] Second branch:

        \item[]
            \begin{minted}{haskell}
            case (g h1 : map g t1) of
              []      -> []
              h0 : t0 -> f h0 : map f t0
            \end{minted}

        \item[] Since \texttt{h0} and \texttt{t0} are linear in the RHS of
            the second branch, we can just do substitution, without introducing
            lets:

        \item[]
            \begin{minted}{haskell}
            f (g h1) : map f (map g t1)
            \end{minted}

        \item[] So we now have:

        \item[]
            \begin{minted}{haskell}
h10 f g a = case a of
              []      -> []
              h1 : t1 -> f (g h1) : map f (map g t1)
            \end{minted}

    \end{itemize}

\end{frame}

\begin{frame}[fragile]

    \begin{itemize}[<+->]
        \item[] As in \texttt{h8}, we again consider alternatives. There's
            nothing to do in first branch.

        \item[]
            \begin{minted}{haskell}
            f (g h1) : map f (map g t1)
            \end{minted}

        \item[]
            This term is already in WHFN, but we consider sub-terms.

        \item[]
            \begin{minted}{haskell}
            f (g h1)
            \end{minted}

        \item[] We can't do anything about this, all names are free. We consider
            the second sub-term.

    \end{itemize}

\end{frame}

\begin{frame}[fragile]

    \begin{itemize}[<+->]

        \item[]
            \begin{minted}{haskell}
            map f (map g t1)
            \end{minted}

        \item[] This looks a lot like one of the terms we compiled before.
            Remember \texttt{h3}:

        \item[]
            \begin{minted}{haskell}
h3 f g a = map f (map g a)
            \end{minted}

        \item[] Our current term is just a renaming of \texttt{h3}. We started
            with \texttt{h3} and came across the same term. If we continue we'll
            loop.

        \item[] Instead, we generate a call to \texttt{h3}.

        \item[]
            \begin{minted}{haskell}
            h3 f g t1
            \end{minted}

        \item[] Since that \texttt{h11} is optimized version of \texttt{h3}, we
            replace the call to \texttt{h3} with a call to \texttt{h11}, and we
            have our final definition:

        \item[]
            \begin{minted}{haskell}
h11 f g a = case a of
              []      -> []
              h1 : t1 -> f (g h1) : h11 f g t1
            \end{minted}

    \end{itemize}

\end{frame}

\begin{frame}[allowframebreaks]
    \frametitle{References}

    \bibliographystyle{abbrvnat}
    \bibliography{refs}
\end{frame}

\end{document}
